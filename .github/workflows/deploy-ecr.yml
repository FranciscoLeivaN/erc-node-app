name: Deploy to LocalStack ECR and Kind

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  DOCKER_IMAGE_NAME: app-inmobiliaria
  AWS_DEFAULT_REGION: us-east-1
  LOCALSTACK_ENDPOINT: http://localhost:4566

jobs:
  # Primer job: Construir y publicar la imagen en DockerHub (opcional)
  build-and-push-dockerhub:
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout del repositorio
        uses: actions/checkout@v4

      - name: Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Iniciar sesión en Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Construir y publicar en Docker Hub
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Segundo job: Trabajar con LocalStack y desplegar en Kind
  build-push-and-deploy:
    needs: build-and-push-dockerhub
    runs-on: ubuntu-latest
    timeout-minutes: 20

    services:
      localstack:
        image: localstack/localstack-pro:latest
        env:
          LOCALSTACK_API_KEY: ${{ secrets.LOCALSTACK_API_KEY }}
          SERVICES: ecr
          DEFAULT_REGION: ${{ env.AWS_DEFAULT_REGION }}
          DEBUG: 1
        ports:
          - 4566:4566
        options: >-
          --health-cmd="curl -f http://localhost:4566/_localstack/health || exit 1"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
      - name: Checkout del repositorio
        uses: actions/checkout@v4

      - name: Configurar Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Instalar herramientas necesarias
        run: |
          pip install awscli-local
          sudo apt-get update && sudo apt-get install -y jq

      - name: Instalar Kind
        uses: helm/kind-action@v1.8.0
        with:
          version: v0.20.0
          install_only: true

      - name: Instalar kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Verificar servicios disponibles
        run: |
          echo "Verificando conectividad con LocalStack..."
          curl -f ${{ env.LOCALSTACK_ENDPOINT }}/_localstack/health || {
            echo "Error: No se puede conectar con LocalStack"
            exit 1
          }

      - name: Esperar a que LocalStack ECR esté listo
        run: |
          echo "Esperando a que ECR esté disponible..."
          for i in {1..12}; do 
            if curl -s ${{ env.LOCALSTACK_ENDPOINT }}/_localstack/health | jq -e '.services.ecr == "running"'; then 
              echo "✅ ECR está listo!"; 
              break; 
            fi; 
            echo "⏳ Intento $i/12 - Esperando a que LocalStack ECR inicie..."; 
            sleep 10; 
          done
          
          # Verificación final
          if ! curl -s ${{ env.LOCALSTACK_ENDPOINT }}/_localstack/health | jq -e '.services.ecr == "running"'; then
            echo "❌ ECR no está disponible después de 2 minutos"
            exit 1
          fi

      - name: Crear repositorio ECR en LocalStack
        id: ecr_repo
        run: |
          echo "Creando repositorio ECR..."
          REPO_JSON=$(awslocal ecr create-repository \
            --repository-name ${{ env.DOCKER_IMAGE_NAME }} \
            --image-scanning-configuration scanOnPush=true \
            --endpoint-url ${{ env.LOCALSTACK_ENDPOINT }} \
            --region ${{ env.AWS_DEFAULT_REGION }})
          
          URI=$(echo $REPO_JSON | jq -r '.repository.repositoryUri')
          echo "✅ Repositorio ECR creado: $URI"
          echo "uri=$URI" >> $GITHUB_OUTPUT

      - name: Construir imagen Docker
        id: build_image
        run: |
          ECR_REPO_URI="${{ steps.ecr_repo.outputs.uri }}"
          IMAGE_TAG="${{ github.sha }}"
          
          FULL_IMAGE_NAME="$ECR_REPO_URI:$IMAGE_TAG"
          SIMPLE_KIND_NAME="${{ env.DOCKER_IMAGE_NAME }}:latest"
          
          echo "🔨 Construyendo imagen Docker..."
          docker build -t "$FULL_IMAGE_NAME" -t "$SIMPLE_KIND_NAME" .
          
          echo "kind_image_name=$SIMPLE_KIND_NAME" >> $GITHUB_OUTPUT
          echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Subir imagen a LocalStack ECR
        run: |
          echo "📤 Subiendo imagen a LocalStack ECR..."
          awslocal ecr get-login-password \
            --endpoint-url ${{ env.LOCALSTACK_ENDPOINT }} \
            --region ${{ env.AWS_DEFAULT_REGION }} | \
            docker login --username AWS --password-stdin ${{ steps.ecr_repo.outputs.uri }}
          
          docker push "${{ steps.build_image.outputs.full_image_name }}"
          echo "✅ Imagen subida exitosamente"

      - name: Crear cluster Kubernetes con Kind
        run: |
          echo "🚀 Creando cluster Kind..."
          kind create cluster --name test-cluster --wait 5m
          
          # Verificar que el cluster está funcionando
          kubectl cluster-info
          kubectl get nodes

      - name: Cargar imagen en Kind
        run: |
          echo "📥 Cargando imagen en Kind..."
          kind load docker-image ${{ steps.build_image.outputs.kind_image_name }} --name test-cluster
          
          # Verificar que la imagen se cargó correctamente
          docker exec test-cluster-control-plane crictl images | grep ${{ env.DOCKER_IMAGE_NAME }} || {
            echo "❌ Error: La imagen no se cargó correctamente en Kind"
            exit 1
          }

      - name: Desplegar aplicación en Kubernetes
        id: deploy
        run: |
          echo "🚀 Desplegando aplicación en Kubernetes..."
          
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.DOCKER_IMAGE_NAME }}-deployment
            labels:
              app: ${{ env.DOCKER_IMAGE_NAME }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ env.DOCKER_IMAGE_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.DOCKER_IMAGE_NAME }}
              spec:
                containers:
                - name: ${{ env.DOCKER_IMAGE_NAME }}-container
                  image: ${{ steps.build_image.outputs.kind_image_name }}
                  ports:
                  - containerPort: 3000
                  resources:
                    requests:
                      memory: "64Mi"
                      cpu: "250m"
                    limits:
                      memory: "128Mi"
                      cpu: "500m"
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 5
                    periodSeconds: 5
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 15
                    periodSeconds: 20
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.DOCKER_IMAGE_NAME }}-service
          spec:
            selector:
              app: ${{ env.DOCKER_IMAGE_NAME }}
            ports:
            - port: 80
              targetPort: 3000
            type: ClusterIP
          EOF
          
          echo "⏳ Esperando a que el despliegue esté listo..."
          kubectl rollout status deployment/${{ env.DOCKER_IMAGE_NAME }}-deployment --timeout=5m

      - name: Verificar estado del despliegue
        if: steps.deploy.outcome == 'success'
        run: |
          echo "✅ Despliegue exitoso! Verificando estado..."
          kubectl get pods -l app=${{ env.DOCKER_IMAGE_NAME }}
          kubectl get services
          kubectl describe deployment ${{ env.DOCKER_IMAGE_NAME }}-deployment

      - name: Diagnóstico en caso de error
        if: failure()
        run: |
          echo "❌ Error en el despliegue. Información de diagnóstico:"
          echo "=== Pods ==="
          kubectl get pods -l app=${{ env.DOCKER_IMAGE_NAME }}
          echo "=== Eventos ==="
          kubectl get events --sort-by=.metadata.creationTimestamp
          echo "=== Logs del deployment ==="
          kubectl describe deployment ${{ env.DOCKER_IMAGE_NAME }}-deployment
          echo "=== Logs de los pods ==="
          kubectl logs -l app=${{ env.DOCKER_IMAGE_NAME }} --all-containers=true

      - name: Limpiar recursos
        if: always()
        run: |
          echo "🧹 Limpiando recursos..."
          kind delete cluster --name test-cluster || true